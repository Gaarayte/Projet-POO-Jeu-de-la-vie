@startuml Conway's Game of Life - Class Diagram

title Diagramme de Classes - Jeu de la Vie (POO Optimal - Final)

skinparam linetype ortho
skinparam monochrome false

package "1. Modèle (Logique Métier - State Pattern)" <<Rectangle>> {

    abstract class CellState {
        + name: string
        --
        + isAlive(): bool {abstract}
        + getNextState(liveNeighbors: int, rule: RuleStrategy): CellState* {abstract}
    }

    class AliveState {
        + AliveState()
        + isAlive(): bool
        + getNextState(liveNeighbors: int, rule: RuleStrategy): CellState*
    }

    class DeadState {
        + DeadState()
        + isAlive(): bool
        + getNextState(liveNeighbors: int, rule: RuleStrategy): CellState*
    }
    
    class FixedState {
        + FixedState(isAlive: bool) // Peut être un obstacle vivant ou mort (fixe)
        + isAlive(): bool
        + getNextState(liveNeighbors: int, rule: RuleStrategy): CellState* // Retourne toujours this
    }

    CellState <|-- AliveState
    CellState <|-- DeadState
    CellState <|-- FixedState

    class Cell {
        - x: int
        - y: int
        - currentState: CellState*
        --
        + Cell(x: int, y: int, initialState: CellState*)
        + setState(newState: CellState*): void
        + getState(): CellState*
        + calculateNextState(liveNeighbors: int, rule: RuleStrategy): CellState*
    }

    class Grid {
        - cells: Cell**
        - width: int
        - height: int
        - nextStateCells: CellState**
        --
        + Grid(width: int, height: int)
        + initialize(parser: InputParser): void
        + calculateLiveNeighbors(x: int, y: int): int
        + evolve(rule: RuleStrategy): bool
        + isStable(): bool
        + applyNextState(): void
        + getCell(x: int, y: int): Cell*
        + getCells(): Cell**
    }

    Cell "1" *-- "1" CellState : détient
    Grid "1" *-- "*" Cell : contient

    note top of Grid
        Implémente le calcul des voisins
        (gestion torique en extension possible ici)
        et la détection de stabilité.
    end note
}

package "2. Stratégie de Règles (Strategy Pattern)" <<Rectangle>> {
    abstract class RuleStrategy {
        + RuleStrategy(name: string)
        --
        + checkSurvival(liveNeighbors: int): bool {abstract}
        + checkBirth(liveNeighbors: int): bool {abstract}
    }

    class Rule {
        + Rule()
        + checkSurvival(liveNeighbors: int): bool
        + checkBirth(liveNeighbors: int): bool
    }

    RuleStrategy <|-- Rule
    CellState "1" o-- "1" RuleStrategy : utilise/évalue
}

package "3. Contrôleur & Utilitaires" <<Rectangle>> {
    class GameOfLife {
        - grid: Grid
        - rule: RuleStrategy
        - view: IView*
        - maxIterations: int
        --
        + GameOfLife(grid: Grid, rule: RuleStrategy, view: IView*)
        + runSimulation(): void
        + setView(view: IView*): void
        + placePredefinedStructure(x: int, y: int, structureType: string): void
    }

    class InputParser {
        + parse(filePath: string): Grid
        + createState(value: int): CellState* // Pour gérer 0, 1 et les obstacles (ex: 2)
    }

    class UnitTests {
        + testEvolution(initialGrid: string, iterations: int, expectedGrid: string): bool
        + testInputParser(filePath: string) const: bool
        + testNeighborCalculation() const: bool
        + runAllTests() const: void
    }

    class GameLogger {
        + logState(grid: Grid, iteration: int): void
    }

    GameOfLife "1" *-- "1" Grid : gère
    GameOfLife "1" *-- "1" RuleStrategy : utilise
}

package "4. Vue (Séparation I/O)" <<Rectangle>> {
    interface IView {
        + initialize(width: int, height: int): void {abstract}
        + render(grid: Grid): void {abstract}
        + handleEvents(): bool {abstract}
    }

    class ConsoleView {
        + render(grid: Grid): void
        + handleEvents(): bool
        - logger: GameLogger
    }

    class SFMLView {
        + render(grid: Grid): void
        + handleEvents(): bool
        + processInput(game: GameOfLife): void
        - window: sf::RenderWindow
        - cellRenderer: SFMLCellRenderer
    }

    class SFMLCellRenderer {
        + drawCell(x: int, y: int, state: CellState*): void
    }
    
    ' Ajout explicite des flèches d'héritage
    IView <|-- ConsoleView
    IView <|-- SFMLView

    GameOfLife "1" o-- "1" IView : utilise (polymorphisme)
    ConsoleView .right.> GameLogger : utilise
    SFMLView "1" o-- "1" SFMLCellRenderer : contient
    SFMLView ..> GameOfLife : interagit (pour placer des structures)
}

InputParser .right.> Grid : crée/initialise

@enduml